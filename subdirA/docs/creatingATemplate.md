# The basics
It's really easy! There are now two ways to create a template.

## The really easy way  - No execution block

This is the method I'm using most of the time now.

Let's look at a real example:

    # Screen config generated by mass
    <~~ screen -t ~%hostName%~ ssh -v ~%IP%~
    
    ~>

For this to work, you need to first send it some data with a command like `--list`. Other this the rest of this document is still relevant.

_IMPORTANT_ Note that the begin block marker is `<~~` instead of `<~`.

## The almost as easy way - With an execution block

NOTE A massive disadvantage of this method is that the template can only be used once. This is because the execution block creates a macro before it can be run. This can only be done once, so the template can only be run once. TODO Refactor to allow an execution block to be run more than once. Potentially this will be ab opportunity for caching.

Let's look at a real example (how --screen used to work):

    # Screen config generated by mass
    <~ macro screenTemplate:
    retrieveResults Screen,sourcelist
    
    ~~screen -t ~%hostName%~ ssh -v ~%IP%~
    
    ~>

Unike a macro, a template does not need a comment on the first line, so that comment is actually going to form part of the output.

So the basic idea is that we execute something between `<~` and `~~`; the *execution block*, and the result array that comes back will be iterated through, and the part of our insertion between the `~~` and `~>`; the *formatting block* formats how each item in the result array will be formatted.

# The details

## The execution block

    <~ macro screenTemplate:
    retrieveResults Screen,sourcelist
    ~~

The first line is actually executing the macro feature which "*Define and run a macro. --macro=macroName:"command1=blah\ncommand2=wheee"*". Ie we create a macro named screenTemplate and immediately run it. In this case the macro contains a single command which gets the results of the screen.macro that invoked the template. 

## The formatting block

Now the second part:
    ~~screen -t ~%hostName%~ ssh -v ~%IP%~
    
    ~>

Note that the formatting is currently a bit screwey! This is to do with new-line feeds. I've done it this way so that we don't _have_ to separate results by new lines.... Because that won't always be correct. :)

TODO unscrewify formatting block of templates.

Let's pretend the results from the section above look like this:

    0: 
      filename: local.hosts.json
      categoryName: local
      hostName: localhost
      internalIP: 127.0.0.1
      externalIP: 
      internalFQDN: localhost
      externalFQDN:
    1: 
      filename: local.hosts.json
      categoryName: local
      hostName: localhost2
      internalIP: 127.0.0.2
      externalIP: 
      internalFQDN: localhost2
      externalFQDN:

Using the formatting block described, we'll get this:

    screen -t localhost ssh -v 127.0.0.1
    screen -t localhost2 ssh -v 127.0.0.2
    

## Putting it all together

In the final output we're going to get a little more. Remember that comment in the beginning?

    # Screen config generated by mass
    
    screen -t localhost ssh -v 127.0.0.1
    screen -t localhost2 ssh -v 127.0.0.2
    

And that's all there is to it! :)

# More uses

## Using a template as default output!

You can now use a template as default output to make the results more human readable. You can see an example of this in list.macro:

    templateOut compactOutput

This gives me output like this:

    [ksandom@k4 templates-enabled]$ mass --list=^lo                                                                                                
    Found hosts                                                                                                                                    
    
    local/localhost
            external:        ()
            internal:       localhost (127.0.0.1)
            chosen:         127.0.0.1

## Using a template as explicit output

Now that a template can take input directly from the result set without the need of an external macro, it's now easier to manipulate output on the fly. Calling it explicitly is one way you can call it multiple times append potentially very different results together.

## Very different results using a single template

You can have as many insertion blocks as you want. The only limitation right now is that every macroName needs to be unique. Any blocks that are using the `<~~` (ie no embedded macro), this is not an issue.

# Quirks and limitations

Non-embedded blocks take their input from the data that was handed to the template when it was called. Therefore if there is a `<~` embedded macro block before a `<~~` non embedded macro block,  the non-embedded block will not reflect any changes the embedded macro may have made. But multiple embedded macros will affect each other.
